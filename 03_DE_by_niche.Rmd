---
title:  "Differential expression - Niches"
output: html_notebook
---


**What is the difference between Crohns Disease and healthy samples; in in different regions of the tissue?**


There are clear 'regions' in the tissue, e.g. a lymphoid region full of T cells and B cells. Or the very outer layer of epithelial, or the basal layer or stromal cells. We can identify and test for differences within these 'niches'. 

```{r}
plotSpatialFeature(sfe.sample.HC,'celltype_subset', colGeometryName = "cellSeg") + 
  theme(legend.title=element_blank()) +
  ggtitle(sample)
```


## Generate niches

We can use 'Banksy' to define niches. Banksy doesn't use use celltypes at all, it uses each cells gene expression, its surrounding gene expresession and the difference between them.

Again, this takes some time to run. The results are alreaady loaded in the sfe object. 

```{r eval=FALSE}

## DO NOT RUN ##

# try to limit to just hvgs
hvgs <- rownames(rowData(sfe))[rowData(sfe)$hvg]
sfe.hvg <- sfe[hvgs,]
sfe.hvg$tissue_sample<- droplevels(sfe.hvg$tissue_sample)

#split by sample
get_one_sample <- function(the_sample){sfe.hvg[,sfe.hvg$tissue_sample == the_sample]}
sfe.list <- lapply(FUN=get_one_sample, X=levels(sfe.hvg$tissue_sample))

# Get the underlaying banky computation
sfe.list <- lapply(sfe.list, computeBanksy, assay_name = 'logcounts', k_geom = k_geom)
sfe.merged <- do.call(cbind, sfe.list)
sfe.merged <- Banksy::runBanksyPCA(sfe.merged, lambda = lamdas, npcs = npcs, group='tissue_sample', seed=12)
sfe.merged <- Banksy::clusterBanksy(sfe.merged, lambda = lamdas, npcs = npcs, resolution = resolutions, seed=12)

niches_table <- colData(sfe.merged)
niche_lookup <- setNames(niches_table$clust_M0_lam0.6_k50_res0.5, nm=as.character( niches_table$cell ))
niche_lookup2 <- setNames(niches_table$clust_M0_lam0.6_k50_res0.3, nm=as.character( niches_table$cell ))
sfe$clust_M0_lam0.6_k50_res0.5 <- niche_lookup[as.character(sfe$cell)]
sfe$clust_M0_lam0.6_k50_res0.3 <- niche_lookup2[as.character(sfe$cell)]
sfe$niche <- factor(paste0('n', as.character(sfe$clust_M0_lam0.6_k50_res0.3)),
                     levels=paste0('n',levels(sfe$clust_M0_lam0.6_k50_res0.3)))

```




```{r}
plotSpatialFeature(sfe.sample.HC, "niche",colGeometryName = "cellSeg") + 
  theme(legend.title=element_blank()) +
  ggtitle(sample)
```


Compare with one of the Chrone's samples.

```{r}
plotSpatialFeature(sfe.sample.CD,'celltype_subset', colGeometryName = "cellSeg") + 
  theme(legend.title=element_blank()) +
  ggtitle(sample)
```

```{r}
plotSpatialFeature(sfe.sample.CD, "niche",colGeometryName = "cellSeg") + # Choose this one
  theme(legend.title=element_blank()) +
  ggtitle(sample)
```



### Explore niches 


What celltypes make up the niches?

Can see that;

* Niche 7 is almost entirely epithelia along the outer edge. 
* Niche 2 is the ephithelia in the epithelial 'crypt' structures in the lamina propria.
* Niche 6 captures the lymphoid regions seen in in HC_a, full of T cells and plasma cells

```{r}
## Celltype proportions
celltype_summary_table<- colData(sfe) %>% as_tibble() %>%
  group_by(celltype_subset, niche ) %>%
  summarise(n_cells = n())

ggplot(celltype_summary_table, aes(fill=celltype_subset, y=n_cells, x=niche) )+
  geom_bar(position="fill", stat="identity") +
  theme_bw() +
  coord_flip() +
  theme(legend.position = "bottom") +
  scale_y_continuous(expand = c(0,0)) +
  ggtitle( "Celltype composition")
```

Likewise, its helpful to see what their proprotions are across different sample. 
This can be quite variable - particularly when we're working on a particularly 
small region of each sample!

```{r}
## Celltype proportions
celltype_summary_table<- colData(sfe) %>% as_tibble() %>%
  group_by(tissue_sample, niche ) %>%
  summarise(n_cells = n())

ggplot(celltype_summary_table, aes(fill=niche, y=n_cells, x=tissue_sample) )+
  geom_bar(position="fill", stat="identity") +
  theme_bw() +
  coord_flip() +
  theme(legend.position = "bottom") +
  scale_y_continuous(expand = c(0,0)) +
  ggtitle( "Niche composition by sample")


```




## Pool samples into pseudobulk

So again - build another pseudobulk, this time on the niche level. 

Build pseudobulk (precomputed)
```{r eval=FALSE}
# DO NOT RUN
sfe$pdb_sample <- paste0(sfe$tissue_sample, '_', sfe$niche)
se.pdb <- aggregateAcrossCells(sfe, ids=sfe$pdb_sample,
                               BPPARAM = MulticoreParam(workers=4)  )
```

Load pseudobulk
```{r}
se.pdb <- readRDS(spe_pseudobulk_by_niche_file)
```




## Filter to a minimum num cells per pool

How many cell per pool?
```{r}
DT::datatable(data.frame(colData(se.pdb))[,c('pdb_sample','individual_code','tissue_sample','niche','ncells')])
```


```{r}
# What is the minimum accepptable number of cells in a pool?

min_cells_per_pdbsample <- 100

ggplot(colData(se.pdb), aes(x=ncells, col=niche)) +
  geom_density() +
  geom_vline(xintercept=min_cells_per_pdbsample, lty=3) +
  geom_rug() +
  scale_x_log10() +
  theme_bw() +
  ggtitle("How many cells per pseduobulk sample?")

```

Apply filter
```{r}
# Filter on minimum number of cells per pdb group
# (ncells column was added by aggregateAcrossCells)
se.pdb <- se.pdb[,se.pdb$ncells >= min_cells_per_pdbsample]
```





## Differential expression

```{r}

# Pull out the pseudoboulk counts matrix for passed samples
pseudobulk_counts_matrix <- counts(se.pdb)
# And the corresponding annotations
pseudobulk_anno_table    <- as_tibble(colData(se.pdb)[,c('pdb_sample','group', 'tissue_sample', 'niche', 'ncells')]) # + any other experimental factors


# Build a table of each contrast we might want to do. 
contrasts_wanted <- bind_cols(
  A= c("CD"), # First terms
  B= c("HC")  # Second terms (usually control)
)


```

```{r}
table(pseudobulk_anno_table$niche, pseudobulk_anno_table$group)
```



```{r}
# Empty list to collect results
de_result_list <- list()

## Cycle through each niche
for (the_niche in levels(se.pdb$niche)) {

  # Subset pseudobulk object to one niche
  se.pdb.this <- se.pdb[,se.pdb$niche == the_niche]
  
  # And pull out the annotation and counts
  anno_table.this   <- as.tibble(colData(se.pdb.this))
  count_matrix.this <- counts(se.pdb.this)

  
  ## Check for sufficient replicates ##
  # To do any calculations, we need at least 2 pseudobulk groups per contrast.
  # there are plenty in this experiemnt, but with less replicates and rare cell types
  # its very common to have to skip some contrats for some niches.

  # skip clusters with no samples after filtering
  if( nrow(anno_table.this) < 1 ) {next}
  
  # Count how many bio samples per group (only need one fov to count it)
  biosample_per_group <- anno_table.this %>% 
    select(group, tissue_sample) %>%
    pull(group) %>% # pull out group column, one entry per tissue sample
    table() # count how many

  # Are there enough Biological smples to consider the contrast?
  min_biosample_per_group <- 2
  enough_biosamples <- 
    (unname(biosample_per_group[contrasts_wanted$A]) >= min_biosample_per_group) &
    (unname(biosample_per_group[contrasts_wanted$B]) >= min_biosample_per_group)
    
  # Make a new table with contrasts that we have enough biosamples for.
  contrasts_to_test <- contrasts_wanted[enough_biosamples,]
  
  # Skip if no contrasts are testable
  if (nrow(contrasts_to_test) == 0) {next}
  
  ## Setup model
  
  # Setup objects for limma
  dge <- DGEList(count_matrix.this)
  dge <- calcNormFactors(dge)
  
  # Build model
  group           <- anno_table.this$group

  # Model design 
  # Add other experimental factors here 
  # ~0 + group
  # ~0 + group + individual
  # ~0 + group + individual + slide
  design    <- model.matrix( ~0 + group)
  
  # Run Voom
  vm  <- voom(dge, design = design, plot = FALSE)
  
  # Adding dupliate correlation to use individual fovs, rather than pooled per biosample
  fit     <- lmFit(vm, design) 

  # Define and fit contrasts and run ebayes
  # Doing this in an automated way so we can include/exvlude contrasts where 
  # there are / arenot enough replicates available. 
  # That's why generatgin a string .
  contrast_str_list <- paste0("group",contrasts_to_test$A,"-","group",contrasts_to_test$B)
  
  contrasts <- makeContrasts(contrasts=contrast_str_list,
                           levels=coef(fit))
  
  fit <- contrasts.fit(fit, contrasts)
  fit <- eBayes(fit)

  
  
  ## Loop through contrasts.
  # You ccan run multiple contrasts at onces, but doing it this way allows us
  # to skip individual contrasts within a niche.
  for ( the_coef in colnames(contrasts) ) {
    # Make a version of the coeffient name that doesn't include a '-', or the 
    # factor name (group)
    # Life is easier without special characters
    # groupUC-groupHC => UCvHC
    contrast_name <- gsub("group","", gsub("-","v",the_coef))
    
    de_result.this <- topTable(fit, n = Inf, adjust.method = "BH", coef = the_coef) %>%
      rownames_to_column("target") %>%
      mutate(contrast=contrast_name,
             contrast_group="pairwise",
             niche=the_niche) %>%
      select(niche,contrast_group, contrast,target,everything()) %>%
      arrange(P.Value)
    
      # build a unique name for this result by adding
      # <niche>_<A>v<B>
      de_result_list[[paste(the_niche, contrast_name, sep="_")]] <- de_result.this
    
  }

}
  
# Join together results for all niches, and pull out those with a singificant adjusted p-value
de_results_all.niche <- bind_rows(de_result_list)
de_results_sig.niche <- filter(de_results_all.niche, adj.P.Val < 0.05)



```

```{r}
DT::datatable(de_results_sig.niche)
```


